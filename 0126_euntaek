은택
페스트 캠퍼스
스프링 강의 ch2- 01~08 학습내용 정리

- HTTP 요청과 응답
    
    
    # 요청과 응답
    
    ## httpServletRequest
    
    url을 호출하면 톰캣이 httpServletRequest객체를 만든다.
    
    이후 url로 요청한 정보를 모두 httpServletRequest에 담는다.
    
    이 담은 정보를 메인 메소드의 매개변수로 전달하는 것.
    
    일반적으로 우리가 자바 클래스에서 사용하는 메인 메소드의 매개변수는 String[] args 문자열 배열이지만 원격 컴퓨터에선 톰캣을 통해 전달된 httpServletRequest객체를 매개변수를 받는다.
    
    ## httpServletRequest의 메서드
    
    ⇒ httpServletRequest를 객체로 받아서 요청에 대한 정보를 얻을 수 있다.
    
    **http://52.24.35.134:8080/ch2/requestInfo?Year=2021&month=10&day=1**
    
    1. getScheme() ⇒ **http**
    2. getSeverName() ⇒ **52.24.35.134**
    3. getServerPort() ⇒ **8080**
    4. getServerPath() ⇒ **requestInfo**
    5. getRequestURI() ⇒ **ch2/requestInfo**
    6. getQueryString() ⇒ **Year=2021&month=10&day=1 ⇒ 값을 전달할 때 사용한다. (구분자는 &표시로, 앞의 값은 name, 뒤의 값은 value)**
    
    [spring_basic/RequestInfo.java at main · castello/spring_basic](https://github.com/castello/spring_basic/blob/main/ch2/RequestInfo.java)
    
    ⇒ httpServletRequest메서드 실행예제
    
    ## HttpServletResponse
    
    ⇒요청에 대한 응답을 브라우저에 바로 띄움
    
    ```jsx
    response.setContentType("text/html"); 
    response.setCharacterEncoding("utf-8");
    PrintWriter out = response.getWriter(); // response객체에서 브라우저로의 출력스트림을 얻는다.
    out.println(year + "년 " + month + "월 " + day + "일은 ");
    out.println(yoil + "요일입니다.");
    ```
    
    response.setContentType("text/html"); ⇒ 출력할 내용 타입
    
    response.setCharacterEncoding("utf-8"); ⇒ 인코딩(안해주면 텍스트 깨짐)
    
    PrintWriter out = response.getWriter(); ⇒ response객체에서 브라우저로의 출력스트림을 얻음
    
- HTTP 요청과 응답2
    
    
    ## 서버가 제공하는 리소스
    
    ### 동적리소스
    
    ⇒ 실행할 때마다 결과가 변한다.
    
    ex)프로그램이 생성해내는 리소스
    
    리소스 내용들이 고정되어있지 않다.
    
    ### 정적리소스
    
    ⇒ 실행할 때마다 결과가 변하지 않는다.
    
    ex) 이미지 파일, JS, CSS, HTML파일
    
    ## 클라이언트와 서버
    
    브라우저로 프로그램을 호출시 서버는 프로그램을 실행하는데 그 결과(응답)가 html로 출력됨 ⇒ text문자열
    
    이때 브라우저가 html을 보여주는 것.
    
    사용자가 요청 ⇒ 요청을 처리 ⇒ 응답 ⇒ 브라우저가 출력
    
- 클라이언트와 서버
    
    ## 클라이언트, 서버란
    
    ### 클라이언트
    
    ⇒ 서비스를 요청하는 애플리케이션 or 컴퓨터
    
    요청하는 역할
    
    ### 서버
    
    ⇒ 서비스를 제공하는 애플리케이션 or 컴퓨터
    
    요청받고 응답하는 역할
    
    **정리**
    
    우리가 사용하는 브라우저가 클라이언트 애플리케이션, 우리가 사용하는 컴퓨터가 클라이언트 컴퓨터
    
    요청을 받은 컴퓨터가 서버, 톰캣이 서버 애플리케이션이라고 할 수 있겠다.
    
    ## 서버
    
    ### 서버의 종류
    
    ⇒ 어떤 서비스를 하느냐에 따라 달라진다.
    
    1. Email Server ⇒ 이메일 서버를 제공
    2. File Sever ⇒ 파일 제공
    3. web server ⇒ 웹 제공(브라우저를 통해 받을 수 있는 모든 서비스 제공)
    
    ### 서버의 포트
    
    만약 한대의 pc에서 여러 서버 프로그램이 존재한다면
    
    ip주소를 가지고 클라이언트 요청을 할 떄 어떤 서버의 요청인지 어떻게 구분하는가?
    
    ⇒ ip주소만으로는 구별이 불가능
    
    **이때 필요한 것이 바로 포트번호이다.**
    
    ⇒ ip주소 뒤에 포트번호도 같이 붙여준다.
    
    **Listening**
    
    ⇒ 한 포드번호당 한 서버만을 연결하는 것
    
    **포트번호**
    
    ⇒ 포트번호는 0~1023번까지 예약되어 있다. ⇒ 못씀
    
    우리는 약 6만개의 포트를 이용할 수 있다.
    
    ## 웹 애플리케이션 서버(was)란
    
    ⇒ WEB server ⇒ 웹을 서비스하는 서버이다.
    
    Was ⇒ 웹 애플리케이션을 서비스한다. ⇒ 서버에 프로그램을 설치해놓고 클라이언트가 이 프로그램을 사용할 수 있도록한다.
    
    ## 톰캣의 내부구조
    
    우리가 요청을 하면 톰캣서버의 스레드가 요청을 처리한다.
    
    톰캣의 내부구조는 다음과 같다.
    
    Server(여러 스레드) > Service(여러 커넥터들) > Engine(context > servlet)
    
    Server ⇒ 스레드 풀이 있음.
    
    Service ⇒ 요청한 컴퓨터에 맞는 프로토콜(커넥션이 있음) 
    
    Engine ⇒ 결과적으로 엔진에서 여러개의context를 지원함.
    
    context ⇒ context하나하나가 웹 애플리케이션이다.
    
    하나의 호스트안에 여러개의 웹 애플리케이션이 설치될 수 있음.
    
    우리기준 스프링의 프로젝트 하나하나가 각각의 context가 되는 것.
    
    sts프로젝트들은 서로영향을 주지 않는 독립적인 공간에서 실행된다.
    
    setvlet =컨트롤러 ⇒ 작은 서버 프로그램
    
    ⇒ 여기서 서비스가 실행되고 결과가 클라이언트의 브라우저로 응답된다.
    
- HTTP 요청과 응답-이론
    
    # 프로토콜이란?
    
    프로토콜 = 서로간의 통신을 위한 약속, 규칙 = 주고받을 데이터에 대한 형식을 정의한 것.
    
    ## HTTP
    
    ⇒ hyper text(html) transfer protocol
    
    ⇒ 텍스트를 전송하기 위한 프로토콜
    
    ### http프로토콜 특징
    
    1.  stateless상태이다. - 상태를 유지하지 않는다. = 데이터 저장을 하지 않는다.
    2.  같은 클라이언트에서 요청을 두 번 보내도 http프로토콜은 두 요청이 동일 클라이언트의 요청인 것을 알지 못한다. ⇒ 상태가 없기에 ⇒ 이를 보완하기 위해 쿠키와 세션을 사용한다.
    3. 확장이 가능하다.
    
    우리가 이전 학습에서 진행했던 “hello”라는 문자열을 브라우저에 출력하기위해 서버에 요청을하고 서버가 응답을 한 결과를 브라우저에 hello문자열을 나타내는 이 과정이 모두 http프로토콜을 지키며 진행되는 것이다.
    
    ## HTTP메세지
    
    ### http요청 응답 과정
    
    우리가 url을 입력하며 요청을 보내지만 실제로는 브라우저가 http 요청메세지를 만들어준다. ⇒ 이게 서버에 도착 ⇒ 서버는 요청에 대한 응답을 해준다. ⇒ 응답 내용이 브라우저에 노출된다.
    
    ### 응답 메세지
    
    - 상태코드-외우기
        
        100~ ⇒ 정보교환
        
        200~ ⇒ 성공
        
        300~ ⇒ 다른 url요청(재요청)
        
        400~ ⇒ 클라이언트 에러
        
        500~ ⇒ 서버 에러
        
    
    **http응답 메세지 형식**
    
    HTTP/1.1 200 Ok  ⇒  상태라인(상태코드 포함 ex-200 ⇒ 요청성공) 
    
    Content-Length : 44                               ⇒ 헤더
    
    Content-Type : text/html                        ⇒ 헤더
    
    Date : sat, 20 Oct 2021 18:33:33 GMT    ⇒ 헤더
    
    이하
    
    html문서                                                 ⇒ 바디
    
    ### 요청 메세지
    
    ⇒ get, post가 존재 ⇒ 모두 요청 방식, 메서드이다.
    
    **get**
    
    ⇒ get은 리소스를 가져오기 위함을 목적으로 사용, 읽기목적 ⇒ ex) 단순히 요청하면 가져오는것
    
    ⇒ get은 바디부분이 없음 대신 **쿼리스트링으로 데이터를 보낼 수 있음(단 작은 용량만)**
    
    ⇒ 데이터 공유에 유리
    
    첫줄이 요청라인
    
    이하 헤더부분
    
    빈줄 ⇒ 헤더가 끝났음을 알림
    
    이하 바디부분(바디부분 비어있음)
    
    **post**
    
    ⇒ post는 get과 달리 **쿼리스트링이(대용량 가능) 바디에 속해있음** ⇒ 서버에 전송할 데이터를 바디에 담고있음
    
    ⇒ get이 읽기위함이면 post는 쓰기 위함 ex) 글쓰기, 파일첨부, 회원가입
    
    ⇒ 데이터 공유에는 불리, 보안에는 유리(단 tls(암호화)가 필요)
    
    첫줄이 요청라인
    
    이하 헤더부분
    
    빈줄 ⇒ 헤더가 끝났음을 알림
    
    이하 바디부분(쿼리스트링 포함)
    
- HTTP 텍스트와 바이너리, MIME, Base64.mp4
    
    
    ## 텍스트 파일 vs 바이너리 파일
    
    **바이너리 파일** : 문자와 숫자가 저장되어 있는 파일
    
    **텍스트 파일** : 문자만 있는 파일
    
    jpg파일을 메모장으로 연다면? ⇒ 이상한 글자들로 다 깨져 보임
    
    메모장은 텍스트 편집기이기에 jpg를 텍스트로 모든 데이터를 표현한다.
    
    일반적으로 우리가 깨진 파일을 받았다면 그건 바이너리 파일이다.
    
    바이너리 파일은 쓸때 읽을때 모두 문자는 문자로 숫자는 숫자로 변환하는 반면
    
    텍스트 파일은 문자는 문자로 쓰나 숫자를 문자로 변환시킨다. 읽을 때는 문자는 문자로 단 문자를 다시 숫자로 변환하지 않는다. ⇒ 그래서 깨지는 것.
    
    ## MIME
    
    그럼 http는 텍스트 기반인데 이미지, 동영상같은 바이너리 파일은 전송하지 못하는 것인가?
    
    아니다. ⇒ MIME를 통해서 문제해결
    
    MIME ⇒ 텍스트 기반 프로토콜(http)에 바이너리 데이터 전송을 위해 고안한 것. ⇒ http content-Type헤더에 사용한다. ⇒ 데이터의 타입을 명시함.
    
    **타입**
    
    ⇒ text, image, audio, video, application등등의 다양한 타입들이 있음
    
    ⇒ 이후 서브타입으로 세세하게 분류함.
    
    포스트맨으로 정보전달할때 value값으로 이미지 파일을 post로 보내면
    
    바디부분 하단에 content-Type으로 image/jpeg라고 표기되어 요청된다.
    
    ## Base64
    
    ⇒ 이때 64는 64진법을 의미
    
    ⇒ 데이터를 표현할때 64개의 심볼을 가지고 표현함
    
    ⇒ 바이너리 데이터를 텍스트 데이터로 변환할 때 사용한다.
    
    다양한 os대상으로 인코딩에 문제가 안생김
    
    안전하게 전달가능하나 데이터가 +33% 더 생김
    
    결론.
    
    바이너리 파일을 http프로토콜로 전달(요청) 할거면
    
    MIME로 데이터 타입 표기로 사용하거나
    
    Base64를 사용해야한다. ⇒ 용량이 좀 커짐